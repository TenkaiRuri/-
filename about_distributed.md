# 【概念】关于「分布式骨架」
最近在思考关于后端分布式调用的问题，因此有了一些大胆的想法。本文意在阐述`「分布式骨架」`的概念。

正因为分布式之间是独立的系统，系统的之间通过例如http，socket，grpc等方法去获取，传递自己系统中所需要的其他参数。当然，不同的后端，team之间实现的方式也会百花齐放。宗旨都只是一个，实现不同系统间参数传递以及交互。

# example
通常我们在编写分布式的时候，并不会单纯的只依赖于单一服务器的数据。一轮响应体(Response)所需要的数据可能会依赖于别的服务器里查询出来的xxx字段，为了完成业务代码，调用逻辑就直接硬编码在业务逻辑里。完成任务的角度上来看或许也是可行的。如果我们遇到了业务上的变更，就不得不得去重构这部分代码。重新编写项目中的代码。这不得不说是很浪费时间的一种行为。

# solve

### 编写响应逻辑
如下伪代码，当我们需要调整业务逻辑的时候 就不得不重构代码
``` rust
fn getValueFromServer() -> T {
  // get value code from request | grpc | socket
  let res = somethingReq()
  res
}
```

### 「分布式骨架」
使用分布式骨架的方式, 通过这样写法，如果业务上有调整，我们只需要重新编写这个闭包，业务上的流程不会有变化。甚至可以将闭包当做为环境变量去使用，逻辑也不需要硬编码在代码中。
``` rust
let logicCode = || { } // Closure code //

fn getValueFromServer<F:Fn() -> T>(f:F) -> T {
  f()
}

fn main() {
  getValueFromServer(logicCode)
}
```

## 映射为模型
将这种关系作为一个数据的模型，利用上述机制我们可以产生如下行为，从不同的服务器上取出前端所需要的参数，通过如下形式作为返回值 （不同服务器之间）

```jsonc
// backend response
{
  "a":"-> req ServerA(logic)", // A 数据通过B服务器获取
  "b":"-> req ServerB(logic)", // 这里的logic可以随时替换,这很重要!!!
}
```

# 关于安全问题
> 我们只需要将闭包的在编译期间编译为二进制，我们就无需担心动态所带来的安全问题